---
title: カーテンの背後にある魔法 – 複雑なセグメント、除外、コンテナ、アトリビューション
description: 複雑なデータセグメント化、除外、コンテナ、アトリビューションモデルの調査の複雑さを明らかにする（_U）。 マジシャンの手品のように、これらのテクニックを習得することで、アナリストはデータマジックを実行し、インサイトを正確かつ洗練されたものに変えることができます
feature: Segmentation
role: User
level: Experienced
doc-type: Article
duration: 36000
last-substantial-update: 2024-03-25T00:00:00Z
jira: KT-15200
thumbnail: KT-15200.jpeg
exl-id: 1da85e88-64b3-49e5-9bf6-76126ac9f6ad
source-git-commit: 69fa16c1bf38604e4dabc553baee71598be83db3
workflow-type: tm+mt
source-wordcount: '4102'
ht-degree: 1%

---

# カーテンの背後にある魔法：複雑なセグメント：除外、コンテナ、およびアトリビューション

_複雑なデータセグメント化、除外、コンテナ、アトリビューションモデルの調査の複雑さを明らかにします。 マジシャンの手品のように、これらのテクニックを習得することで、アナリストはデータマジックを実行し、インサイトを正確かつ洗練されたものに変えることができます。_

カーテンが開いていて、ステージがセットされています…これはラスベガスの魔法の行為ではないかもしれませんが、セグメントを構築するときにかなり素晴らしいトリックを実行できます。

![ 魔術師_ハンズ ](assets/magician-hands.jpeg)

このモジュールでは、以下について説明します。

- ロジックの除外
- コンテナの使用
- アトリビューションモデル

## 含む/除外

デフォルトでは、すべてのコンテナは **含める** タイプとして開始されます。これは基本的に、条件に一致するデータを返すことを意味します。 ただし、セグメントやセグメント内のコンテナを **除外** タイプに変更して、特定の条件を却下することもできます。

魔術師はデッキであなたのカードを見つけることができますが、その魔術師がデッキの残りの部分を存在させることができないとき、それは素晴らしいことです。 同様に、除外セグメントでは、不要なデータがデータセットから単に消去されます。

![ 名刺 ](assets/blankcards.png)

「でも、私はすでに『等しくない』オプションと『含まない』オプションを持っているので、それは私を覆うべきではないのですか？」と考えているかもしれません。 残念ながら、それに対する答えは何でもありません。単にロジックのグループを 1 つの要素で除外できるだけではありません。 単一のコンポーネントを処理する場合でも、目標を達成するために *除外* を使用する必要が生じる場合がよくあります。

- **次を含まない/等しくない** – 特定の文字列を含まない項目に一致して、そのまま表示されます。
- **除外：値に/が含まれる** – 文字列に一致する項目を *除外* します

一見すると、これらの両方とも同じように聞こえます…そして、**ヒット** レベルのセグメント/コンテナでは、同じアクションを実行するので、正しいでしょう。 ただし、**visit** または **visitor** スコープを使用すると、まったく異なる結果が得られます。

**図 1：次を含まない/等しくない – ヒットスコープ**

![ 図 1-DnceVsExclude-Hit](assets/figure1-dnce-vs-exclude-hit.png)

*各ヒットが true または false の値を返し、これらの値は not と exclude の間で反転されます。*

- 「Value」に「Example」が含まれていない（はい）場合は、true を返し、そのヒットを含めます。同様に、「Example」には「Example」が含まれていない（含まれていない）場合は、false を返し、そのヒットを含めません。 基本的に、true の結果を返すデータを返します。
- 「Value」に「Example」（いいえ）が含まれる場合は false を返し、そのヒットを除外しません。同様に、「Example」に「Example」（はい）が含まれる場合は true を返し、そのヒットを除外します。 基本的に、結果が true **ない** データを返すか、条件に false のデータを返します。
- **ヒット** レベルでは、両方のロジックセットが同じデータセットを返します。

**図 2：次を含まない/等しくない – 訪問範囲**

![ 図 2-DnceVsExclude-Visit](assets/figure2-dnce-vs-exclude-visit.png)

*上記のように、**visit**内の各ヒットは、同じ true/false で評価されます。 ただし、返されるデータセットは、訪問全体のデータセットです。*

- 各ヒットで、「Value」に「Example」が含まれていない（はい）場合は true を返します。同様に、「Example」に「Example」が含まれていない（含まれていない）場合は false を返します。
   - 訪問中に **any** ヒットが **true** を返した場合、**訪問全体** が返されます。*
   - 訪問が完全に「Example」を含むヒットで構成されている場合、ヒットは true を返さないので、データセットでその訪問は **返されません**。
- ここでも、各ヒットで「Example」に「Example」（yes）が含まれているため、は true を返します
   - **いずれかのヒット** が **true** を返した場合、訪問全体が **除外** されます
   - 訪問中の **すべてのヒット** が **false** を返した場合、その訪問はデータセットに返されます
- これで、このロジックが分岐し始める場所を確認できます。 上記の例では、3 つの異なる訪問があります。
   - 「次を含まない/等しい」 **3 つのうち 2 つ** を使用する場合、訪問が返されます。
   - 「次を含む/次と等しい **を使用する場合、これらの訪問のうち 1 つのみ** が返されます

**図 3：次を含まない/等しくない – 訪問範囲**

![ 図 3-DnceVsExclude-Visitor](assets/figure3-dnce-vs-exclude-visitor.png)

*上記のように、**visitor**によって行われた各ヒットは、同じ true/false ロジックで評価されます。 ただし、現在は、この訪問者が行ったすべてのヒットを、すべての訪問（選択した日付範囲内）にわたって確認しています。*

- 各ヒットで、「Value」に「Example」が含まれていない（はい）場合は true を返します。同様に、「Example」に「Example」が含まれていない（含まれていない）場合は false を返します。
   - 訪問者によって行われた **any** ヒットが **true** を返した場合、**訪問全体** が返されます。
   - 訪問者が「Example」を含むヒットをまったく行わなかった場合、どのヒットも true を返さないので、その訪問者はデータセットに **返されません**。
- ここでも、各ヒットで「Example」に「Example」（yes）が含まれているため、は true を返します。
   - **いずれかのヒット** が **true** を返した場合、訪問者全体（およびその後のすべての訪問）が **除外** されます。
   - 訪問中の **すべてのヒット** が **false** を返した場合、その訪問者はデータセットに返され、「X」を行わなかった訪問者が正常に返されます。
- これは訪問ロジックの拡張であり、さらに多くの考慮事項があります。 上記の例では、2 人の異なる訪問者がいて、それぞれ 3 回の訪問があります。
   - 「次を含まない/等しい **を使用する場合（両方** 訪問者が返されます。また、すべての訪問 **3** と同様です（2 人の訪問者と 6 人の合計訪問回数をレポートに含む）
   - 「次を含む/等しい **を使用する場合、そのうち 1 つのみ** の訪問者が返され、その訪問者に関連付けられた 3 回の訪問のみが含まれます（レポートでの訪問者の数は 1 回と合計訪問数は 3 回です）

>[!TIP]
>
>このロジックは複雑になる場合があります。特にコンテナのネストを開始する場合は、制御されたサンプルデータに対してテストを実行し、セグメントが実際には必要と思われるデータを返していることを確認することをお勧めします。

### セグメントの例 1：購入をおこなう訪問の除外

この例では、サイトを訪問し、訪問中に購入を行 *なかった* ユーザーをターゲットにします（基本的には、トランザクションを実行した訪問を除外します。したがって、トランザクションを完了しなかった訪問が残ります）

![Segment1A-VisitLevelExclude](assets/segment-example-1/segment1a-visit-level-exclude.png)

比較のために、「存在しない」を使用して作成されたセグメントを見てみましょう。

![Segment1B-VisitDoesNotExist](assets/segment-example-1/sement1b-visit-does-not-exist.png)

プレビューには非常に異なる結果がどのように表示されるかを確認してください。実際、すべての訪問に「注文」指標を含まない少なくとも 1 つのヒットがあるので、このセグメントは訪問の 100% を返します。

これを詳しく説明するために、2 つのセグメントを並べて比較しましょう。

![Segment1C-ComparisonTable](assets/segment-example-1/sement1c-comparison-table.png)

まず、セグメントの *訪問* レベルの範囲に関わらず、セグメントと他の指標（ページビュー、ユニーク訪問者など）をペアにできることを確認できます。 列の最初のセットはセグメント化されておらず、1 つのセグメント（存在しない）が約 100% のデータを返していることを一目で示すことができ、除外セグメントのみが必要な処理を行っています。

最も顕著な列は注文です。ほとんどの注文がまだ返されているので、「存在しない」コンテナが間違っていることがすぐに明らかになるはずです。

### セグメント例 2：レポート期間内に購入を行った訪問者を除外

この例では、前のサンプル（特に訪問レベルで見た）のアイデアを使用し、それを展開して、レポートの期間内に購入を行っていない訪問者を見つけたいと考えています。

このセグメントは、上記の例と非常に似ていますが、ほぼ同じですが、セグメントの範囲は大きな違いがあります。

![Segment2A-VisitorLevelExclude](assets/segment-example-2/segment2a-visitor-level-exclude.png)

現在は、訪問者の範囲を指定したセグメントと上記の訪問の範囲を指定したセグメントを比較すると、より多くのデータと、より多くの訪問が除外されていることがわかります。これは、*購入を行った訪問者* には購入が行われなかった訪問もあるため、これらの訪問も訪問者のライフサイクルの一環として除外されるからです。

>[!IMPORTANT]
>
>訪問者スコープのデータを調べる場合、多くの訪問者がサイトを訪問した常連訪問者となるので、レポート期間が長いほど除外が大きくなります（もちろん、一部のビジネスモデルでは他のモデルよりも大きな影響が見られます）

![Segment2B-ComparisonTable](assets/segment-example-2/sement2b-comparison-table.png)


>[!IMPORTANT]
>
>訪問と訪問者の違いは *微妙* 場合がありますが（特にこのサンプルデータでは）、考慮する必要がある独自のロジックです。 サイトやユーザーの行動によっては、データが大きく異なる場合があります。


レポートで伝えようとしているデータや *ストーリー* を正確に把握することが重要です。 適切な分析を行うためには、テーブルとビジュアライゼーションが表示されているオーディエンス ***何*** を明確に伝え、適切なセグメントモデルを使用していることが重要です。 十分な情報に基づいた意思決定は、誰もが自分の見ているものを理解している場合にのみ、適切に行うことができます。

## コンテナの使用

コンテナを使用すると、セグメントのメインロジック内に「サブロジック」を作成できます。一般的な誤解として、セグメントとコンテナの間ではスコープがすべて同じである必要がありますが、同じではないことがあります。これにより、より大きなスキームで特定のシナリオを作成し、複雑なロジックを構築する自由が増します。

コンテナについて考える最善の方法は、各コンテナがボックスであり、（論理の）ボックスを別のボックス内に積み重ねることができることです。しかし、各ボックスが外側のボックスよりも小さくなければならない物理的なボックスとは異なり、正しいデータを取り戻す必要がある場合は、内側に大きなものを入れることができます。 不可能が中に収まることができ、私たちはデータの魔術師である魔術師の帽子のように考えてください。

![Rabbit_in_hat](assets/rabbit-in-hat.jpeg)

### 容器の範囲

まず、*container* 範囲の簡単な分類を行います。 *segment s* cope と同様に、基本的な **ヒット**、**訪問**、**訪問者** 範囲のオプションがありますが、訪問者の代わりに **論理グループ** と呼ばれるものも表示される場合があります（これは順次セグメント内でのみ発生し、次の記事で説明します）。

セグメント内（または他のコンテナ内）にコンテナを追加するには、**options*** メニューにアクセスします（複数の項目をネストする場合は、正しいブロックに追加するように注意します。ただし、間違った場所に追加すると、インターフェイス内でコンテナをドラッグ&amp;ドロップできます）

**図 1: コンテナの追加**

![ 図 1 – コンテナの追加 ](assets/figure1-adding-container.png)

コンテナの範囲は親とは無関係です。前述のように、これらは一致する必要はありません ** し、戻りたいものによっては、少なくとも頭の中で快適に視覚化できるようになるまで、必要なものを完全に視覚化するための計画を引き出す必要がある場合があります。

**図 2：セグメントスコープとコンテナスコープ**

![ 図 2-SegmentScopeVsContainerScope](assets/figure2-segment-scope-vs-container-scope.png)

>[!NOTE]
>
>Adobeには、有効なセグメントと無効なセグメントを理解するロジックがあり、機能しない *可能性のあるオプションは提供されません*。したがって、ヒットスコープのセグメント内で訪問者スコープのコンテナを使用するオプションが表示される場合、これは有効なオプションであることを意味します。

基本セグメントと同様に、ネストされたコンテナで複雑なセグメントの作成を開始する場合は、返されるデータの種類 ***何*** について明確に理解している必要があります。 ***どのように*** そのデータを使用する予定ですか？ ***セグメントとペアリングする予定の指標はどれですか***

これらの質問は、セグメント全体の範囲を決定するのに役立ちます。これは、任意のセグメントの出発点です。

セグメントをユニーク訪問者指標とペアにする予定だからといって、セグメント自体を訪問者レベルから離れたレベルにする必要はありません。 訪問者レベルのセグメントは、訪問者のすべてのデータを返します。つまり、訪問者のすべての訪問、すべてのページビューなどを返します。訪問者がセグメント条件に一致すると、（ワークスペースの日付範囲内にある限り）この訪問者の *過去* のデータがセグメントに返されるようになります。

>[!IMPORTANT]
>
>セグメントをユニーク訪問者指標とペアにすることを計画している場合でも、これは *必ずしも* セグメントを自動的に訪問者範囲にする必要があります…この誤解は *可能性があります* 膨張した誤った結果を生み出します。

適切な範囲の選択方法に関する概念についてはたくさん話しましたが、実際に役立つ例や詳細については説明していません。それでは、実際のユースケースの例をいくつか見てみましょう。 魔術師は決して秘密を明かさないというが、それは全く真実ではない。 魔法の世界では、テクニックと「カーテンの後ろ」の作業は仲間と共有されることが多く、錯覚を積み重ねて改善することを可能にします。それが、私が目指していることです。. .あなたを待っている可能性への扉を開くために。

### セグメントの例 3：最近の注文を行った訪問者からの特定ページに対するビュー（レポート期間内）

このシナリオでは、最近の購入者によってヒットした特定のページのセットのみを返します（セグメント自体はヒットの範囲になりますが、これを訪問数やユニーク訪問者数と組み合わせることはできます）。

このタイプのシナリオは、購入者がサイト上の特定のページ（特定のイベントに明示的に接続されていない可能性のあるページ）を閲覧する場合に役立ちます。

この例では、「おすすめ商品」と「おすすめ商品」のページを見ていきます。 現在、ロジックをシンプルに保ち、順次セグメント化には進みません（少なくともまだですが、将来の記事ではそのような複雑なロジックに対処します）。

もう 1 つの質問は **なぜ** ヒットによって引き戻されるのでしょうか。 技術的には、ここでは訪問または訪問者によって取り込むことができますが、これらの特定のページを、訪問ごとの **ページビュー（特定のページセット用））または** 訪問者ごとの **ページビュー（特定のセット用）** でも見たいと思うかもしれません。この範囲を使用すると、この特定の計算を柔軟に実行できます。 これらのヒットは訪問またはユニーク訪問者と簡単にペアにして、これらのページを表示する訪問または訪問者の数を決定できるので、すべてのシナリオで使用できる最も柔軟なセグメントを選択します。

まず、比較のために、特定のページの単純なヒットベースのセグメントを以下に示します。

![Segment3A-HitLevelPages](assets/segment-example-3/segment3a-hit-level-pages.png)

次に、複雑さを増していきます。

![Segment3B-MultipleContainersHitAndVisitor](assets/segment-example-3/segment3b-multiple-containers-hit-and-visitor.png)

私は複数のコンテナを使用しているだけでなく、それらのコンテナの範囲を混在させていることに注意してください。 セグメント全体としてはヒットレベルですが、注文した訪問者も探しています。

![Segment3C-ComparisonTable](assets/segment-example-3/segment3c-comparison-table.png)

荷を解くのに少し時間を費やしましょう。多くのことが起こっているので。

まず、毎日の分類を表示するのではなく、ページの分類を表示します。これにより、2 つのセグメントがよりよく説明されると思われるので、

<table style="border: 0;">
    <tr>
        <td width="352" style="border: 0;">最初の 3 つの列（ページビュー、訪問回数、ユニーク訪問者）はセグメント化されていないので、サイト内のすべてのページが表示されます。 注文はアクションで追跡され、したがってページディメンションの範囲の一部ではないので、ここでは注文を含めなかったことに注意してください。</td>
        <td style="border: 0;">&lt;img src="assets/segment-example-3/segment3c-comparison-table-detail1.png" width="352"
        </td>
    </tr>
</table>

<table style="border: 0;">
    <tr>
        <td width="352" style="border: 0;">次に、指定した 2 つのページの <strong> ヒット数 </strong> のみを見て、単純なセグメントの結果を表示します。 分類内の他のページはすべて、期待どおりに 0 になります。</td>
        <td style="border: 0;">&lt;img src="assets/segment-example-3/segment3c-comparison-table-detail2.png" width="352"
        </td>
    </tr>
</table>

<table style="border: 0;">
    <tr>
        <td width="352" style="border: 0;">ここで、少しボーナスのヒントを紹介します。高度なセグメントの結果を表示する前に、「注文が存在する」という別のシンプルなセグメント（ヒットレベルの範囲）を使用し、ユニーク訪問者とペアにしました。 これにより、レポート期間中に注文した UV の合計と、これらの各ページにヒットした UV が返されます。これにより、次の列セットをより適切に説明できます。</td>
        <td style="border: 0;">&lt;img src="assets/segment-example-3/segment3c-comparison-table-detail3.png" width="352"
        </td>
    </tr>
</table>

<table style="border: 0;">
    <tr>
        <td width="352" style="border: 0;">最終的な列セットは、複雑なセグメントで積み重ねられます。 注文を含む全体の UV は、各ページの単純な「注文が存在する」セグメントと一致しますが、合計が大きく異なることがわかります。このデータセットは、注文を行ってページにヒットした訪問者にのみデータセットを明示的に制限するので、私は明示的に興味があります。</td> <td style="border: 0;"><img src="assets/segment-example-3/segment3c-comparison-table-detail4.png" width="352">
        </td>
    </tr>
</table>

### セグメントの例 4：おすすめの取引または推奨製品にヒットし、同じ訪問内で注文する訪問

上記のサンプルでは、より大きな範囲コンテナ（訪問者）をより小さな範囲コンテナ（ヒット）に追加する方法を示したので、訪問者または訪問の範囲セグメント内にヒットコンテナを追加できることに驚くことはありません。

以前に見ていたのと同じページを使用して、現在は、おすすめ商品ページまたは推奨製品ページをヒットして、同じ訪問内で注文した訪問者を取り戻すことを気にしています。

![Segment4A-VisitorWithVisit](assets/segment-example-4/segment4a-visitor-with-visit.png)

このセグメントは、3 つの範囲をすべて混在させます。 セグメントの最上位レベルは訪問者なので、これにより、一致する訪問者にすべての訪問からのすべてのヒットが返されます。 その中に訪問範囲コンテナを追加しました。これにより、訪問者は、注文を行い、特定のページを訪問した特定の条件に一致する訪問を少なくとも 1 回持っている必要があります。 ページ自体にヒットの範囲コンテナを追加しました。これにより、OR ロジックを使用して、おすすめ取引ページまたは推奨製品ページのいずれかを探すことができます。

この訪問者スコープのセグメントの利点は、この条件に一致する訪問者からの **すべて** の訪問を返すことです。そのため、この組み合わせにつながる以前の訪問の行動と、そのようなシナリオの後のこれらの訪問者の行動を確認したい場合は、このセグメントが適しています。

![Segment4B-ComparisonTable](assets/segment-example-4/segment4b-comparison-table.png)

ここでは、おすすめの取引/推奨コンテンツのヒットと、注文が存在することと、注文と指定したページの両方が同じ訪問に存在する複雑なセグメントを比較しています。 複合セグメントでは 2 つの最初のセグメントが交差します。ただし、これは訪問者の範囲なので、これらの訪問者に対する他のすべての訪問も返されます。

## アトリビューションモデル

セグメント定義内のアトリビューションモデリングは、主にヒットなしの有効期限を持つディメンションに関係するので、（常にヒットレベルである） prop は本当に良い候補ではありません。 eVar、マーケティングチャネルなど。 ただし、実際には、これらの設定は何のために設計されているかです。

セグメントを見る前に、簡単な例でアトリビューションモデリングの仕組みをすばやく確認する必要があります。

例えば、2 つの eVar があり、そのうちの 1 つが有効期限（eVar1）を訪問するように設定され、そのうちの 1 つが 30 日の有効期限（eVar2）に設定されているとします。 簡単にするために、内部キャンペーン（icid）をトラッキングします。

**1 にアクセス**

- ページ A
   - **eVar 1** が設定されていません
   - **eVar2** が設定されていません
- URL に？icid=promo-banner が含まれているプロモバナーをクリックします
- ページ B
   - **eVar1** および **eVar2** は「プロモバナー」に設定されています
   - **eVarのインスタンス 1** がトリガーされる
   - **eVarのインスタンス 2** がトリガーされる
- ページ C
   - **eVar1} と** eVar2 **の両方が** 値「promo-banner」を維持しています
   - 両方の eVar が持続値を使用しているので、eVar のインスタンス指標は実行されません

**Visit 2**

- ページ D
   - **eVar 1** はどの値にも設定されておらず、**eVar 1 のインスタンス** がトリガーされません
   - **eVar2** 30 日の有効期限が切れているため、「プロモバナー」値を維持します
   - 値が永続的で、実際には設定されていないので、**eVar2 のインスタンス** はトリガーされません
- URL で？icid=promo-side-rail を含んだサイドパネルプロモーションをクリックします
- ページ E
   - **eVar1** および **eVar2** は「プロモサイドレール」に設定されています
   - **eVarのインスタンス 1** がトリガーされる
   - **eVarのインスタンス 2** がトリガーされる
- ページ F
   - **eVar1} と** eVar2 **の両方** 値「プロモサイドレール」を維持しています
   - 両方の eVar が持続値を使用しているので、eVar のインスタンス指標は実行されません

現在、これら 2 つの訪問で期待される結果は次のとおりです。

<table><tr><th colspan="1" valign="top"></th><th colspan="1" valign="top"></th><th colspan="1" valign="top"><b>ページビュー数</b></th><th colspan="1" valign="top"><b>訪問回数</b></th><th colspan="1" valign="top"><b>eVarのインスタンス 1</b></th><th colspan="1" valign="top"><b>eVarのインスタンス 2</b></th></tr>
<tr><td colspan="1" valign="top"></td><td colspan="1" valign="top"></td><td colspan="1" valign="top">6</td><td colspan="1" valign="top">2</td><td colspan="1" valign="top">2</td><td colspan="1" valign="top">2</td></tr>
<tr><td colspan="1" rowspan="7" valign="top">ページ</td><td colspan="1" valign="top"></td><td colspan="1" valign="top">6</td><td colspan="1" valign="top">2</td><td colspan="1" valign="top">2</td><td colspan="1" valign="top">2</td></tr>
<tr><td colspan="1" valign="top">ページ A</td><td colspan="1" valign="top">1</td><td colspan="1" valign="top">1</td><td colspan="1" valign="top">0</td><td colspan="1" valign="top">0</td></tr>
<tr><td colspan="1" valign="top">ページ B</td><td colspan="1" valign="top">1</td><td colspan="1" valign="top">1</td><td colspan="1" valign="top">1</td><td colspan="1" valign="top">1</td></tr>
<tr><td colspan="1" valign="top">ページ C</td><td colspan="1" valign="top">1</td><td colspan="1" valign="top">1</td><td colspan="1" valign="top">0</td><td colspan="1" valign="top">0</td></tr>
<tr><td colspan="1" valign="top">ページ D</td><td colspan="1" valign="top">1</td><td colspan="1" valign="top">1</td><td colspan="1" valign="top">0</td><td colspan="1" valign="top">0</td></tr>
<tr><td colspan="1" valign="top">ページ E</td><td colspan="1" valign="top">1</td><td colspan="1" valign="top">1</td><td colspan="1" valign="top">1</td><td colspan="1" valign="top">1</td></tr>
<tr><td colspan="1" valign="top">ページ F</td><td colspan="1" valign="top">1</td><td colspan="1" valign="top">1</td><td colspan="1" valign="top">0</td><td colspan="1" valign="top">0</td></tr>
</table>

<table><tr><th colspan="1" valign="top"></th><th colspan="1" valign="top"></th><th colspan="1" valign="top"><b>ページビュー数</b></th><th colspan="1" valign="top"><b>訪問回数</b></th><th colspan="1" valign="top"><b>eVarのインスタンス 1</b></th></tr>
<tr><td colspan="1" valign="top"></td><td colspan="1" valign="top"></td><td colspan="1" valign="top">4</td><td colspan="1" valign="top">2</td><td colspan="1" valign="top">2</td></tr>
<tr><td colspan="1" rowspan="3" valign="top">eVar1</td><td colspan="1" valign="top"></td><td colspan="1" valign="top">4</td><td colspan="1" valign="top">2</td><td colspan="1" valign="top">2</td></tr>
<tr><td colspan="1" valign="top">プロモバナー</td><td colspan="1" valign="top">2</td><td colspan="1" valign="top">1</td><td colspan="1" valign="top">1</td></tr>
<tr><td colspan="1" valign="top">プロモサイドレール</td><td colspan="1" valign="top">2</td><td colspan="1" valign="top">1</td><td colspan="1" valign="top">1</td></tr>
</table>

<table><tr><th colspan="1" valign="top"></th><th colspan="1" valign="top"></th><th colspan="1" valign="top"><b>ページビュー数</b></th><th colspan="1" valign="top"><b>訪問回数</b></th><th colspan="1" valign="top"><b>eVarのインスタンス 2</b></th></tr>
<tr><td colspan="1" valign="top"></td><td colspan="1" valign="top"></td><td colspan="1" valign="top">5</td><td colspan="1" valign="top">2</td><td colspan="1" valign="top">2</td></tr>
<tr><td colspan="1" rowspan="3" valign="top">eVar2</td><td colspan="1" valign="top"></td><td colspan="1" valign="top">5</td><td colspan="1" valign="top">2</td><td colspan="1" valign="top">2</td></tr>
<tr><td colspan="1" valign="top">プロモバナー</td><td colspan="1" valign="top">3</td><td colspan="1" valign="top">2</td><td colspan="1" valign="top">1</td></tr>
<tr><td colspan="1" valign="top">プロモサイドレール</td><td colspan="1" valign="top">2</td><td colspan="1" valign="top">1</td><td colspan="1" valign="top">1</td></tr>
</table>

次に、セグメントでアトリビューションを設定できる場所を見てみましょう。

**図 4: アトリビューションモデル**

![ 図 4-AttributionModel](assets/figure4-attribution-model.png)

*ディメンションの歯車アイコンで、アトリビューションを設定できます。 各オプションには、「?」にカーソルを合わせたときに利用できる情報があります。 アイコン。 基本的に：*

- デフォルトの動作では、値が設定されたeVarのすべてのインスタンス（具体的には、または set attribution を通じて）が返されます
- インスタンスは、値が明示的に設定されている（例：「eVarのインスタンス」がトリガーされるヒットで）ディメンションのみを返します
- 繰り返さないインスタンスは、ディメンションの値が初めて設定された場合にのみ返されます（例：上記の例では扱われていませんが、ユーザーがプロモバナーを複数回クリックした場合、バナーがクリックされるたびに「eVarのインスタンス」が増分されます。この設定では、「プロモバナー」の最初の一意のインスタンスのみが取得され、このバナーの後続のカウントは無視されます）

### セグメントの例 5：マーケティングチャネルの「有料検索」と有料検索のダイレクトインスタンスの比較

ご存知のように、マーケティングチャネルには長いアトリビューションモデルがあります（デフォルトでは 30 日ですが、これは独自のニーズに合わせてカスタマイズできます）。設定すると、マーケティングチャネルは、その後のサイトへの「直接」訪問で上書きされないため、特定のドライバーがコンバージョンアトリビューションを取得できます。 ただし、特定のマーケティングチャネルによって、サイトに特別に ***エントリ*** を表示する必要がある場合があります。また、エントリによって、マーケティング処理ルールに基づいてマーケティングチャネルが特別に設定されているタイミングを確認する必要があります。

物事を変更し、比較を見ることから始めましょう。その後、セグメントを掘り下げます。

![Segment5A-TableComparison](assets/segment-example-5/segment5a-table-comparison.png)

<table style="border: 0;">
    <tr>
        <td width="352" style="border: 0;">最初の 4 列はセグメント化されておらず、理解しやすいはずです。 なお、「エントリ」は基本的に、訪問者のセッション開始時の位置に基づいて計算された値です。 ユーザーは複数のマーケティングチャネル（ソーシャルメディアの閲覧、検索の実行、マーケティングメールのクリックなど）を通じてサイトに入る可能性があるので、探している情報が返されないことを示すために、ここに追加しました。 すべて同じ訪問/ セッション内）。</td> <td style="border: 0;"><img src="assets/segment-example-5/segment5a-table-comparison-detail1.png" width="352">
        </td>
    </tr>
</table>

<table style="border: 0;">
    <tr>
        <td width="352" style="border: 0;">次の列のセットでは、「標準ヒットセグメント」を使用し、基本的にマーケティングチャネルが「有料検索」であるヒットを調べます。 ただし、これはマーケティングチャネルアトリビューションに基づいてすべてのヒットを返し、実際の「有料検索」クリックスルーを分離しません。 したがって、必要なデータは返されません。</td> <td style="border: 0;"><img src="assets/segment-example-5/segment5a-table-comparison-detail2.png" width="352">
        </td>
    </tr>
</table>


![Segment5A-PaidSearchHit](assets/segment-example-5/segment5a-paid-search-hit.png)

<table style="border: 0;">
    <tr>
        <td width="352" style="border: 0;">次の 2 つのデータセットは同じように見えますが、実際には、これらは 2 つの異なる方法で同じデータを返します。 しかし現在は、マーケティングチャネルが <strong> 設定 </i> された <i> インスタンス </strong> を「有料検索」に特化して見ています。</td> <td style="border: 0;"><img src="assets/segment-example-5/segment5a-table-comparison-detail3.png" width="352">
        </td>
    </tr>
</table>

これを行うには、次の 2 つの方法があります。

まず、「標準」ディメンション アトリビューションを使用し、これと特定の「マーケティングチャネルインスタンス」指標（*存在* ロジック）をペアにします。

![Segment5A-PaidSearchHitANDInstanceExists](assets/segment-example-5/segment5a-paid-search-hit-and-instance-exists.png)

または、よりシンプルなセグメントの場合は、アトリビューションを「インスタンス」に変更できます。 ディメンション名が「マーケティングチャネル」から「マーケティングチャネル（インスタンス）」に変更されます。

![Segment5A-PaidSearchHitInstance](assets/segment-example-5/segment5a-paid-search-hit-instance.png)

## まとめ

他の優れた魔術師のように、私たちは個々のトリックから始めて、行く途中でオーディエンスを構築し、最終的な「名声」に導くことができます。 ここで私たちは本当に輝いています。小さなトリックをすべて取り込み、グランドフィナーレにロールアップします。 一見切り離されたトリックの一部を取り、実際には、それらすべてが団結した全体を形成するために一緒に働くことを示しています。

![ ファイアーバニー ](assets/fire-bunny.jpeg)


### セグメント例 6：有料ソーシャルインスタンスでの訪問中に注文し、ニュースレターに新規登録した訪問者を除外した訪問者

![Segment6A-VisitorsPurchasingFromPaidSocialWithNoNewsletter](assets/segment-example-6/segment6a-visitors-purchasing-from-paid-social-with-no-newsletter.png)

これにより、ソーシャルメディアキャンペーンからの訪問中に積極的に購入したが、ニュースレターに登録していない訪問者を識別できます。 これにより、マーケティングチームは、ニュースレターやマーケティングメールに試して変換するユーザーの潜在的なグループを確認できます。

## フィナーレ

![ 劇場_舞台 ](assets/theater-stage.jpeg)

ロジックを組み合わせて非常に詳細なシナリオを作成する方法はたくさんあるので、可能性の表面を傷つけるだけです。

他の偉大な魔術師のように、真の力は、新進気鋭の世代を刺激して、基礎に基づいて学んだことを新しく素晴らしいものに再考させることです。 皆様のご意見をお待ちしております！

## 作成者

このドキュメントの作成者：

![Jen Headshot](assets/jen-headshot.png)

Jennifer Dungan （Torstar 社 Optimization Manager Analytics）

Adobe Analytics チャンピオン

