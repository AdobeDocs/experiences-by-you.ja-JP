---
title: カーテンの背後にある魔法 – 複雑なセグメント、除外、コンテナ、アトリビューション
description: 複雑なデータセグメント化、除外、コンテナ、アトリビューションモデルの調査の複雑さを明らかにする（_U）。 マジシャンの手品のように、これらのテクニックを習得することで、アナリストはデータマジックを実行し、インサイトを正確かつ洗練されたものに変えることができます
feature: Segmentation
role: User
level: Experienced
doc-type: Article
duration: 36000
last-substantial-update: 2024-03-25T00:00:00Z
jira: KT-15200
thumbnail: KT-15200.jpeg
exl-id: 1da85e88-64b3-49e5-9bf6-76126ac9f6ad
source-git-commit: 59dbe503fb179ed24ec8380f0d3e853deec82a7b
workflow-type: tm+mt
source-wordcount: '4102'
ht-degree: 2%

---

# カーテンの背後にある魔法：複雑なセグメント：除外、コンテナ、およびアトリビューション

_複雑なデータセグメント化、除外、コンテナ、アトリビューションモデルの調査の複雑さを明らかにします。 マジシャンの手品のように、これらのテクニックを習得すると、アナリストはデータマジックを実行し、インサイトを正確かつ洗練されたものに変えることができます。_

カーテンが開いていて、ステージがセットされています…これはラスベガスの魔法の行為ではないかもしれませんが、セグメントを構築するときにかなり素晴らしいトリックを実行できます。

![手品師](assets/magician-hands.jpeg)

このモジュールでは、以下について説明します。

- ロジックの除外
- コンテナの使用
- アトリビューションモデル

## 含む/除外

デフォルトでは、すべてのコンテナはとして開始されます。 **次を含める** タイプ。基本的には、条件に一致するデータが返されます。 ただし、セグメントやセグメント内のコンテナをに変更することもできます **除外** タイプを入力すると、特定の条件を却下できます。

魔術師はデッキであなたのカードを見つけることができますが、その魔術師がデッキの残りの部分を存在させることができないとき、それは素晴らしいことです。 同様に、除外セグメントでは、不要なデータがデータセットから単に消去されます。

![無表情な](assets/blankcards.png)

「でも、私はすでに『等しくない』オプションと『含まない』オプションを持っているので、それは私を覆うべきではないのですか？」と考えているかもしれません。 残念ながら、それに対する答えは何でもありません。単にロジックのグループを 1 つの要素で除外できるだけではありません。 単一のコンポーネントを処理する場合でも、多くの場合、を使用する必要があります *除外* 目標を達成するために使用します。

- **次を含まない/等しくない**  – 特定の文字列を含まない項目に一致して、そのまま表示されます
- **除外：値が/を含む**  – このウィル *除外* 文字列に一致する項目

一見すると、どちらも同じように聞こえます…そして上に **ヒット** セグメント/コンテナのレベルを設定する場合は同じアクションを実行するので、正しく設定されます。 ただし、を使用するときは **訪問** または **訪問者** 範囲あなたは大きく異なる結果を得るでしょう。

**図 1：次を含まない/等しくない – ヒット範囲**

![図 1-DnceVsExclude-Hit](assets/figure1-dnce-vs-exclude-hit.png)

*各ヒットが true または false の値を返し、これらの値が not と exclude の間で反転されることに注意してください。*

- 「Value」に「Example」が含まれていない（はい）場合は、true を返し、そのヒットを含めます。同様に、「Example」には「Example」が含まれていない（含まれていない）場合は、false を返し、そのヒットを含めません。 基本的に、true の結果を返すデータを返します。
- 「Value」に「Example」（いいえ）が含まれる場合は false を返し、そのヒットを除外しません。同様に、「Example」に「Example」（はい）が含まれる場合は true を返し、そのヒットを除外します。 基本的に、以下を実行するデータを返します **ではない** true の結果が得られるか、条件に false のデータが返されます。
- それはから確認できます **ヒット** level を指定すると、両方の論理セットが同じデータのセットを返します。

**図 2：次を含まない/等しくない – 訪問範囲**

![図 2-DnceVsExclude-Visit](assets/figure2-dnce-vs-exclude-visit.png)

*上記のように、内の各ヒット&#x200B;**訪問**は、同じ true/false で評価されます。 ただし、返されるデータセットは、訪問全体のデータセットです。*

- 各ヒットで、「Value」に「Example」が含まれていない（はい）場合は true を返します。同様に、「Example」に「Example」が含まれていない（含まれていない）場合は false を返します。
   - 次の場合 **いずれか** 訪問再来訪のヒット **true**&#x200B;を選択し、続いて **全体の訪問** が返されます。*
   - 訪問が完全に「例」を含んだヒットで構成されている場合、ヒットは true を返さないので、その訪問は次のようになります **返されない** をデータセットに追加します。
- ここでも、各ヒットで「Example」に「Example」（yes）が含まれているため、は true を返します
   - 次の場合 **任意のヒット** 戻り値 **true**&#x200B;の場合、訪問全体は次のようになります **除外済み**
   - 次の場合 **すべてのヒット** 再来訪で **偽**&#x200B;その後、その訪問はデータセットに返されます
- これで、このロジックが分岐し始める場所を確認できます。 上記の例では、3 つの異なる訪問があります。
   - 「次を含まない/等しい」を使用する場合 **3 つの中の 2** 訪問が返されます。
   - 「次を含む/次と等しい除外」を使用する場合 **1 つのみ** これらの訪問のうち、が返されます

**図 3：次を含まない/等しくない – 訪問の範囲**

![図 3-DnceVsExclude-Visitor](assets/figure3-dnce-vs-exclude-visitor.png)

*上記のように、によって行われたそれぞれのヒット&#x200B;**訪問者**は、同じ true / false ロジックで評価されます。 ただし、現在は、この訪問者が行ったすべてのヒットを、すべての訪問（選択した日付範囲内）にわたって確認しています。*

- 各ヒットで、「Value」に「Example」が含まれていない（はい）場合は true を返します。同様に、「Example」に「Example」が含まれていない（含まれていない）場合は false を返します。
   - 次の場合 **いずれか** 訪問者の再来訪で発生したヒット **true**&#x200B;を選択し、続いて **全体の訪問** が返されます。
   - 訪問者が「Example」を含むヒットをまったく行わなかった場合、どのヒットも true を返さないので、その訪問者は **返されない** をデータセットに追加します。
- ここでも、各ヒットで「Example」に「Example」（yes）が含まれているため、は true を返します。
   - 次の場合 **任意のヒット** 戻り値 **true**&#x200B;の場合、訪問者全体（およびそれ以降のすべての訪問）は **除外。**
   - 次の場合 **すべてのヒット** 再来訪で **偽**&#x200B;その場合、その訪問者はデータセットに返され、「X」を実行しなかった訪問者が正常に返されます。
- これは訪問ロジックの拡張であり、さらに多くの考慮事項があります。 上記の例では、2 人の異なる訪問者がいて、それぞれ 3 回の訪問があります。
   - 「次を含まない/等しい」を使用する場合 **両方** 訪問者は、すべてと同様に返されます **三** 訪問回数の（レポートでの 2 回の訪問者と 6 回の合計訪問回数を計算）
   - 「次を含む/次と等しい除外」を使用する場合 **1 つのみ** このうち、訪問者が返され、その訪問者に関連付けられた 3 回の訪問のみが含まれます（レポートにおける 1 回の訪問者と 3 回の合計訪問回数を計算）

>[!TIP]
>
>このロジックは複雑になる場合があります。特にコンテナのネストを開始する場合は、制御されたサンプルデータに対してテストを実行し、セグメントが実際には必要と思われるデータを返していることを確認することをお勧めします。

### セグメントの例 1：購入をおこなう訪問の除外

この例では、サイトにアクセスして以下を行ったユーザーをターゲットにします *ではない* 訪問中に購入します（基本的には、トランザクションを実行した訪問を除外します。そのため、トランザクションを完了しなかった訪問が残ります）。

![Segment1A-VisitLevelExclude](assets/segment-example-1/segment1a-visit-level-exclude.png)

比較のために、「存在しない」を使用して作成されたセグメントを見てみましょう。

![セグメント 1B – 訪問が存在しない](assets/segment-example-1/sement1b-visit-does-not-exist.png)

プレビューには非常に異なる結果がどのように表示されるかを確認してください。実際、すべての訪問に「注文」指標を含まない少なくとも 1 つのヒットがあるので、このセグメントは訪問の 100% を返します。

これを詳しく説明するために、2 つのセグメントを並べて比較しましょう。

![Segment1C-ComparisonTable](assets/segment-example-1/sement1c-comparison-table.png)

まず、 *訪問* セグメントのレベル範囲。セグメントと他の指標（ページビュー、ユニーク訪問者など）をペアにすることができます。 列の最初のセットはセグメント化されておらず、1 つのセグメント（存在しない）が約 100% のデータを返していることを一目で示すことができ、除外セグメントのみが必要な処理を行っています。

最も顕著な列は注文です。ほとんどの注文がまだ返されているので、「存在しない」コンテナが間違っていることがすぐに明らかになるはずです。

### セグメント例 2：レポート期間内に購入を行った訪問者を除外

この例では、前のサンプル（特に訪問レベルで見た）のアイデアを使用し、それを展開して、レポートの期間内に購入を行っていない訪問者を見つけたいと考えています。

このセグメントは、上記の例と非常に似ていますが、ほぼ同じですが、セグメントの範囲は大きな違いがあります。

![Segment2A-VisitorLevelExclude](assets/segment-example-2/segment2a-visitor-level-exclude.png)

これで、訪問者スコープのセグメントを上記の訪問スコープのセグメントと比較すると、以下のように、より多くのデータと、より多くの訪問が除外されていることがわかります *購入を行った訪問者* また、には購入が行われなかった訪問もあり、これらの訪問も訪問者のライフサイクルの一部なので除外されます。

>[!IMPORTANT]
>
>訪問者スコープのデータを調べる場合、多くの訪問者がサイトを訪問した常連訪問者となるので、レポート期間が長いほど除外が大きくなります（もちろん、一部のビジネスモデルでは他のモデルよりも大きな影響が見られます）

![Segment2B-ComparisonTable](assets/segment-example-2/sement2b-comparison-table.png)


>[!IMPORTANT]
>
>訪問と訪問者の違いは次の通りです *微妙な* （特にこのサンプルデータでは）これらは、考慮が必要な一意のロジックです。 サイトやユーザーの行動によっては、データが大きく異なる場合があります。


どのデータが何であるかを正確に把握することが重要です *ストーリー*&#x200B;あなたは報告書を伝えようとしています。 テーブルとビジュアライゼーションでオーディエンスをはっきりと示すようにします ***対象*** が表示されるので、適切なセグメントモデルを使用することは、適切な分析を行うために重要です。 十分な情報に基づいた意思決定は、誰もが自分の見ているものを理解している場合にのみ、適切に行うことができます。

## コンテナの使用

コンテナを使用すると、セグメントのメインロジック内に「サブロジック」を作成できます。一般的な誤解として、セグメントとコンテナの間ではスコープがすべて同じである必要がありますが、同じではないことがあります。これにより、より大きなスキームで特定のシナリオを作成し、複雑なロジックを構築する自由が増します。

コンテナについて考える最善の方法は、各コンテナがボックスであり、（論理の）ボックスを別のボックス内に積み重ねることができることです。しかし、各ボックスが外側のボックスよりも小さくなければならない物理的なボックスとは異なり、正しいデータを取り戻す必要がある場合は、内側に大きなものを入れることができます。 不可能が中に収まることができ、私たちはデータの魔術師である魔術師の帽子のように考えてください。

![Rabbit_in_hat](assets/rabbit-in-hat.jpeg)

### 容器の範囲

まず、の分類を簡単に行います。 *コンテナ* スコープ。 類似 *セグメント*&#x200B;対処、あなたはあなたの基本を持っている **ヒット**, **訪問** および **訪問者** スコープのオプションですが、時々あなたはと呼ばれるものも見るでしょう **論理グループ** 訪問者の代わりに（これは順次セグメント内でのみ発生します。次の記事で説明します）。

セグメント内（または他のコンテナ内）にコンテナを追加するには、 **オプション*** メニュー（複数の項目をネストする場合は、正しいブロックに追加するように注意してください。ただし、間違った場所に追加すると、インターフェイス内でコンテナをドラッグ&amp;ドロップできます）

**図 1: コンテナの追加**

![図 1 – コンテナの追加](assets/figure1-adding-container.png)

コンテナの範囲は、前述のように、親とは独立しています。 *実行しない* 一致する必要があり、戻りたいものに応じて、少なくとも頭の中で快適に視覚化するまで、必要なものを完全に視覚化するために計画を引き出す必要がある場合があります。

**図 2: セグメント範囲とコンテナ範囲**

![図 2-SegmentScopeVsContainerScope](assets/figure2-segment-scope-vs-container-scope.png)

>[!NOTE]
>
>Adobeには、有効なセグメントと無効なセグメントを理解するためのロジックがあり、次のようなオプションは提供されません *なし* 動作…したがって、ヒットスコープのセグメント内で訪問者スコープのコンテナを使用するオプションが表示された場合、これは有効なオプションであることを意味します。

基本セグメントと同様に、ネストされたコンテナを使用して複雑なセグメントの作成を開始する場合は、次について明確に理解する必要があります ***対象*** 返されるデータの種類。 ***方法*** あなたはそのデータを使うつもりですか？ ***対象*** 指標はセグメントとペアにすることを計画していますか？

これらの質問は、セグメント全体の範囲を決定するのに役立ちます。これは、任意のセグメントの出発点です。

セグメントをユニーク訪問者指標とペアにする予定だからといって、セグメント自体を訪問者レベルから離れたレベルにする必要はありません。 訪問者レベルのセグメントは、訪問者のすべてのデータを返します。つまり、訪問者のすべての訪問、すべてのページビューなどを返します。訪問者がセグメント条件に一致すると、セグメントは以下からのデータを返し始める場合があります *過去* （ワークスペースの日付範囲内である限り）この訪問者に対して。

>[!IMPORTANT]
>
>セグメントとユニーク訪問者指標のペアを計画している場合でも、これは *次を意味しない* セグメントが自動的に訪問者スコープ設定されるようにするには…この誤解 *可能性* 水増しされた誤った結果を作成します。

適切な範囲の選択方法に関する概念についてはたくさん話しましたが、実際に役立つ例や詳細については説明していません。それでは、実際のユースケースの例をいくつか見てみましょう。 魔術師は決して秘密を明かさないというが、それは全く真実ではない。 魔法の世界では、テクニックと「カーテンの後ろ」の作業は仲間と共有されることが多く、錯覚を積み重ねて改善することを可能にします。それが、私が目指していることです。. .あなたを待っている可能性への扉を開くために。

### セグメントの例 3：最近の注文を行った訪問者からの特定ページに対するビュー（レポート期間内）

このシナリオでは、最近の購入者によってヒットした特定のページのセットのみを返します（セグメント自体はヒットの範囲になりますが、これを訪問数やユニーク訪問者数と組み合わせることはできます）。

このタイプのシナリオは、購入者がサイト上の特定のページ（特定のイベントに明示的に接続されていない可能性のあるページ）を閲覧する場合に役立ちます。

この例では、「おすすめ商品」と「おすすめ商品」のページを見ていきます。 現在、ロジックをシンプルに保ち、順次セグメント化には進みません（少なくともまだですが、将来の記事ではそのような複雑なロジックに対処します）。

もう一つの質問は **理由** 私たちはヒットによって引っ張り戻していますか？ 技術的には、ここでは訪問回数や訪問者数で引き出すことができますが、以下で特定のページを調べる必要もあります **（特定のページセットの） 1 訪問あたりのページビュー数** または **訪問者ごとの（特定のセットの）ページビュー数**&#x200B;このスコープを使用すると、この特定の計算を柔軟に実行できます。 これらのヒットは訪問またはユニーク訪問者と簡単にペアにして、これらのページを表示する訪問または訪問者の数を決定できるので、すべてのシナリオで使用できる最も柔軟なセグメントを選択します。

まず、比較のために、特定のページの単純なヒットベースのセグメントを以下に示します。

![Segment3A-HitLevelPages](assets/segment-example-3/segment3a-hit-level-pages.png)

次に、複雑さを増していきます。

![Segment3B-MultipleContainersHitAndVisitor](assets/segment-example-3/segment3b-multiple-containers-hit-and-visitor.png)

私は複数のコンテナを使用しているだけでなく、それらのコンテナの範囲を混在させていることに注意してください。 セグメント全体としてはヒットレベルですが、注文した訪問者も探しています。

![Segment3C-ComparisonTable](assets/segment-example-3/segment3c-comparison-table.png)

荷を解くのに少し時間を費やしましょう。多くのことが起こっているので。

まず、毎日の分類を表示するのではなく、ページの分類を表示します。これにより、2 つのセグメントがよりよく説明されると思われるので、

<table border="0">
    <tr>
        <td width="352" style="border: 0;">最初の 3 つの列（ページビュー、訪問回数、ユニーク訪問者）はセグメント化されていないので、サイト内のすべてのページが表示されます。 注文はアクションで追跡され、したがってページディメンションの範囲の一部ではないので、ここでは注文を含めなかったことに注意してください。</td>
        <td style="border: 0;">&lt;img src="assets/segment-example-3/segment3c-comparison-table-detail1.png" width="352"
        </td>
    </tr>
</table>

<table border="0">
    <tr>
        <td width="352" style="border: 0;">次に、単純なセグメントの結果を、 <strong>ヒット数</strong> 指定した 2 つのページ 分類内の他のページはすべて、期待どおりに 0 になります。</td>
        <td style="border: 0;">&lt;img src="assets/segment-example-3/segment3c-comparison-table-detail2.png" width="352"
        </td>
    </tr>
</table>

<table border="0">
    <tr>
        <td width="352" style="border: 0;">ここで、少しボーナスのヒントを紹介します。高度なセグメントの結果を表示する前に、「注文が存在する」という別のシンプルなセグメント（ヒットレベルの範囲）を使用し、ユニーク訪問者とペアにしました。 これにより、レポート期間中に注文した UV の合計と、これらの各ページにヒットした UV が返されます。これにより、次の列セットをより適切に説明できます。</td>
        <td style="border: 0;">&lt;img src="assets/segment-example-3/segment3c-comparison-table-detail3.png" width="352"
        </td>
    </tr>
</table>

<table>
    <tr>
        <td width="352" style="border: 0;">最終的な列セットは、複雑なセグメントで積み重ねられます。 注文を含む全体の UV は、各ページの単純な「注文が存在する」セグメントと一致しますが、合計が大きく異なることがわかります。このデータセットは、注文を行ってページにヒットした訪問者にのみデータセットを明示的に制限するので、私は明示的に興味があります。</td> <td style="border: 0;"><img src="assets/segment-example-3/segment3c-comparison-table-detail4.png" width="352">
        </td>
    </tr>
</table>

### セグメントの例 4：おすすめの取引または推奨製品にヒットし、同じ訪問内で注文する訪問

上記のサンプルでは、より大きな範囲コンテナ（訪問者）をより小さな範囲コンテナ（ヒット）に追加する方法を示したので、訪問者または訪問の範囲セグメント内にヒットコンテナを追加できることに驚くことはありません。

以前に見ていたのと同じページを使用して、現在は、おすすめ商品ページまたは推奨製品ページをヒットして、同じ訪問内で注文した訪問者を取り戻すことを気にしています。

![Segment4A-VisitorWithVisit](assets/segment-example-4/segment4a-visitor-with-visit.png)

このセグメントは、3 つの範囲をすべて混在させます。 セグメントの最上位レベルは訪問者なので、これにより、一致する訪問者にすべての訪問からのすべてのヒットが返されます。 その中に訪問範囲コンテナを追加しました。これにより、訪問者は、注文を行い、特定のページを訪問した特定の条件に一致する訪問を少なくとも 1 回持っている必要があります。 ページ自体にヒットの範囲コンテナを追加しました。これにより、OR ロジックを使用して、おすすめ取引ページまたは推奨製品ページのいずれかを探すことができます。

この訪問者スコープのセグメントの利点は、が返されることです **すべて** この条件に一致する訪問者からの訪問数なので、この組み合わせにつながる以前の訪問の行動と、そのようなシナリオの後のこれらの訪問者の行動を確認する場合は、このセグメントが適しています。

![Segment4B-ComparisonTable](assets/segment-example-4/segment4b-comparison-table.png)

ここでは、おすすめの取引/推奨コンテンツのヒットと、注文が存在することと、注文と指定したページの両方が同じ訪問に存在する複雑なセグメントを比較しています。 複合セグメントでは 2 つの最初のセグメントが交差します。ただし、これは訪問者の範囲なので、これらの訪問者に対する他のすべての訪問も返されます。

## アトリビューションモデル

セグメント定義内のアトリビューションモデリングは、主にヒットなしの有効期限を持つディメンションに関係するので、（常にヒットレベルである） prop は本当に良い候補ではありません。 eVar、マーケティングチャネルなど。 ただし、実際には、これらの設定は何のために設計されているかです。

セグメントを見る前に、簡単な例でアトリビューションモデリングの仕組みをすばやく確認する必要があります。

例えば、2 つの eVar があり、そのうちの 1 つが有効期限（eVar1）を訪問するように設定され、そのうちの 1 つが 30 日の有効期限（eVar2）に設定されているとします。 簡単にするために、内部キャンペーン（icid）をトラッキングします。

**訪問 1**

- ページ A
   - **EVAR 1** が設定されていません
   - **EVAR 2** が設定されていません
- URL に？icid=promo-banner が含まれているプロモバナーをクリックします
- ページ B
   - **EVAR 1** および **EVAR 2** 「プロモバナー」に設定されている
   - **eVarのインスタンス 1** がトリガーされる
   - **eVarのインスタンス 2** がトリガーされる
- ページ C
   - 両方 **EVAR 1** および **EVAR 2** 値「プロモバナー」を維持する
   - 両方の eVar が持続値を使用しているので、eVar のインスタンス指標は実行されません

**訪問 2**

- ページ D
   - **EVAR 1** は任意の値に設定されておらず、も設定されていない **eVarのインスタンス 1** がトリガーされる
   - **EVAR 2** 30 日の有効期限が切れるため、「プロモバナー」値を維持します
   - **eVarのインスタンス 2** 値が永続的で、実際には設定されていないので、はトリガーされません
- URL で？icid=promo-side-rail を含んだサイドパネルプロモーションをクリックします
- ページ E
   - **EVAR 1** および **EVAR 2** 「プロモサイドレール」に設定されている
   - **eVarのインスタンス 1** がトリガーされる
   - **eVarのインスタンス 2** がトリガーされる
- ページ F
   - 両方 **EVAR 1** および **EVAR 2** 「プロモサイドレール」値の維持
   - 両方の eVar が持続値を使用しているので、eVar のインスタンス指標は実行されません

現在、これら 2 つの訪問で期待される結果は次のとおりです。

<table><tr><th colspan="1" valign="top"></th><th colspan="1" valign="top"></th><th colspan="1" valign="top"><b>ページビュー数</b></th><th colspan="1" valign="top"><b>訪問回数</b></th><th colspan="1" valign="top"><b>eVarのインスタンス 1</b></th><th colspan="1" valign="top"><b>eVarのインスタンス 2</b></th></tr>
<tr><td colspan="1" valign="top"></td><td colspan="1" valign="top"></td><td colspan="1" valign="top">6</td><td colspan="1" valign="top">2</td><td colspan="1" valign="top">2</td><td colspan="1" valign="top">2</td></tr>
<tr><td colspan="1" rowspan="7" valign="top">ページ</td><td colspan="1" valign="top"></td><td colspan="1" valign="top">6</td><td colspan="1" valign="top">2</td><td colspan="1" valign="top">2</td><td colspan="1" valign="top">2</td></tr>
<tr><td colspan="1" valign="top">ページ A</td><td colspan="1" valign="top">1</td><td colspan="1" valign="top">1</td><td colspan="1" valign="top">0</td><td colspan="1" valign="top">0</td></tr>
<tr><td colspan="1" valign="top">ページ B</td><td colspan="1" valign="top">1</td><td colspan="1" valign="top">1</td><td colspan="1" valign="top">1</td><td colspan="1" valign="top">1</td></tr>
<tr><td colspan="1" valign="top">ページ C</td><td colspan="1" valign="top">1</td><td colspan="1" valign="top">1</td><td colspan="1" valign="top">0</td><td colspan="1" valign="top">0</td></tr>
<tr><td colspan="1" valign="top">ページ D</td><td colspan="1" valign="top">1</td><td colspan="1" valign="top">1</td><td colspan="1" valign="top">0</td><td colspan="1" valign="top">0</td></tr>
<tr><td colspan="1" valign="top">ページ E</td><td colspan="1" valign="top">1</td><td colspan="1" valign="top">1</td><td colspan="1" valign="top">1</td><td colspan="1" valign="top">1</td></tr>
<tr><td colspan="1" valign="top">ページ F</td><td colspan="1" valign="top">1</td><td colspan="1" valign="top">1</td><td colspan="1" valign="top">0</td><td colspan="1" valign="top">0</td></tr>
</table>

<table><tr><th colspan="1" valign="top"></th><th colspan="1" valign="top"></th><th colspan="1" valign="top"><b>ページビュー数</b></th><th colspan="1" valign="top"><b>訪問回数</b></th><th colspan="1" valign="top"><b>eVarのインスタンス 1</b></th></tr>
<tr><td colspan="1" valign="top"></td><td colspan="1" valign="top"></td><td colspan="1" valign="top">4</td><td colspan="1" valign="top">2</td><td colspan="1" valign="top">2</td></tr>
<tr><td colspan="1" rowspan="3" valign="top">eVar1</td><td colspan="1" valign="top"></td><td colspan="1" valign="top">4</td><td colspan="1" valign="top">2</td><td colspan="1" valign="top">2</td></tr>
<tr><td colspan="1" valign="top">プロモバナー</td><td colspan="1" valign="top">2</td><td colspan="1" valign="top">1</td><td colspan="1" valign="top">1</td></tr>
<tr><td colspan="1" valign="top">プロモサイドレール</td><td colspan="1" valign="top">2</td><td colspan="1" valign="top">1</td><td colspan="1" valign="top">1</td></tr>
</table>

<table><tr><th colspan="1" valign="top"></th><th colspan="1" valign="top"></th><th colspan="1" valign="top"><b>ページビュー数</b></th><th colspan="1" valign="top"><b>訪問回数</b></th><th colspan="1" valign="top"><b>eVarのインスタンス 2</b></th></tr>
<tr><td colspan="1" valign="top"></td><td colspan="1" valign="top"></td><td colspan="1" valign="top">5</td><td colspan="1" valign="top">2</td><td colspan="1" valign="top">2</td></tr>
<tr><td colspan="1" rowspan="3" valign="top">eVar2</td><td colspan="1" valign="top"></td><td colspan="1" valign="top">5</td><td colspan="1" valign="top">2</td><td colspan="1" valign="top">2</td></tr>
<tr><td colspan="1" valign="top">プロモバナー</td><td colspan="1" valign="top">3</td><td colspan="1" valign="top">2</td><td colspan="1" valign="top">1</td></tr>
<tr><td colspan="1" valign="top">プロモサイドレール</td><td colspan="1" valign="top">2</td><td colspan="1" valign="top">1</td><td colspan="1" valign="top">1</td></tr>
</table>

次に、セグメントでアトリビューションを設定できる場所を見てみましょう。

**図 4: アトリビューションモデル**

![図 4 – 属性モデル](assets/figure4-attribution-model.png)

*ディメンションの歯車アイコンで、アトリビューションを設定できます。 各オプションには、「?」にカーソルを合わせたときに利用できる情報があります。 アイコン。 基本的に、*

- デフォルトの動作では、値が設定されたeVarのすべてのインスタンス（具体的には、または set attribution を通じて）が返されます
- インスタンスは、値が明示的に設定されている（例：「eVarのインスタンス」がトリガーされるヒットで）ディメンションのみを返します
- 繰り返さないインスタンスは、ディメンションの値が初めて設定された場合にのみ返されます（例：上記の例では扱われていませんが、ユーザーがプロモバナーを複数回クリックした場合、バナーがクリックされるたびに「eVarのインスタンス」が増分されます。この設定では、「プロモバナー」の最初の一意のインスタンスのみが取得され、このバナーの後続のカウントは無視されます）

### セグメントの例 5：マーケティングチャネルの「有料検索」と有料検索のダイレクトインスタンスの比較

ご存知のように、マーケティングチャネルには長いアトリビューションモデルがあります（デフォルトでは 30 日ですが、これは独自のニーズに合わせてカスタマイズできます）。設定すると、マーケティングチャネルは、その後のサイトへの「直接」訪問で上書きされないため、特定のドライバーがコンバージョンアトリビューションを取得できます。 ただし、特にを確認する必要がある場合があります ***エントリ*** を特定のマーケティングチャネルによってサイトに誘導します。また、エントリによって、マーケティング処理ルールに基づいてマーケティングチャネルが特別に設定されたタイミングを確認する必要があります。

物事を変更し、比較を見ることから始めましょう。その後、セグメントを掘り下げます。

![Segment5A-TableComparison](assets/segment-example-5/segment5a-table-comparison.png)

<table>
    <tr>
        <td width="352" style="border: 0;">最初の 4 列はセグメント化されておらず、理解しやすいはずです。 なお、「エントリ」は基本的に、訪問者のセッション開始時の位置に基づいて計算された値です。 ユーザーは複数のマーケティングチャネル（ソーシャルメディアの閲覧、検索の実行、マーケティングメールのクリックなど）を通じてサイトに入る可能性があるので、探している情報が返されないことを示すために、ここに追加しました。 すべて同じ訪問/ セッション内）。</td> <td style="border: 0;"><img src="assets/segment-example-5/segment5a-table-comparison-detail1.png" width="352">
        </td>
    </tr>
</table>

<table>
    <tr>
        <td width="352" style="border: 0;">次の列のセットでは、「標準ヒットセグメント」を使用し、基本的にマーケティングチャネルが「有料検索」であるヒットを調べます。 ただし、これはマーケティングチャネルアトリビューションに基づいてすべてのヒットを返し、実際の「有料検索」クリックスルーを分離しません。 したがって、必要なデータは返されません。</td> <td style="border: 0;"><img src="assets/segment-example-5/segment5a-table-comparison-detail2.png" width="352">
        </td>
    </tr>
</table>


![Segment5A-PaidSearchHit](assets/segment-example-5/segment5a-paid-search-hit.png)

<table>
    <tr>
        <td width="352" style="border: 0;">次の 2 つのデータセットは同じように見えますが、実際には、これらは 2 つの異なる方法で同じデータを返します。 しかし、今、私は特に <i>instances</i> マーケティングチャネルの場所 <strong>set</strong> を「ペイド検索」に変更します。</td> <td style="border: 0;"><img src="assets/segment-example-5/segment5a-table-comparison-detail3.png" width="352">
        </td>
    </tr>
</table>

これを行うには、次の 2 つの方法があります。

まず、「標準」ディメンション アトリビューションを使用し、これと特定の「マーケティングチャネルインスタンス」指標（ *が存在する* ロジック）:

![Segment5A-PaidSearchHitANDInstanceExists](assets/segment-example-5/segment5a-paid-search-hit-and-instance-exists.png)

または、よりシンプルなセグメントの場合は、アトリビューションを「インスタンス」に変更できます。 ディメンション名が「マーケティングチャネル」から「マーケティングチャネル（インスタンス）」に変更されます。

![Segment5A-PaidSearchHitInstance](assets/segment-example-5/segment5a-paid-search-hit-instance.png)

## まとめ

他の優れた魔術師のように、私たちは個々のトリックから始めて、行く途中でオーディエンスを構築し、最終的な「名声」に導くことができます。 ここで私たちは本当に輝いています。小さなトリックをすべて取り込み、グランドフィナーレにロールアップします。 一見切り離されたトリックの一部を取り、実際には、それらすべてが団結した全体を形成するために一緒に働くことを示しています。

![火_バニー](assets/fire-bunny.jpeg)


### セグメント例 6：有料ソーシャルインスタンスでの訪問中に注文し、ニュースレターに新規登録した訪問者を除外した訪問者

![Segment6A-VisitorsPurchasingFromPaidSocialWithNoNewsletter](assets/segment-example-6/segment6a-visitors-purchasing-from-paid-social-with-no-newsletter.png)

これにより、ソーシャルメディアキャンペーンからの訪問中に積極的に購入したが、ニュースレターに登録していない訪問者を識別できます。 これにより、マーケティングチームは、ニュースレターやマーケティングメールに試して変換するユーザーの潜在的なグループを確認できます。

## フィナーレ

![Theater_Stage](assets/theater-stage.jpeg)

ロジックを組み合わせて非常に詳細なシナリオを作成する方法はたくさんあるので、可能性の表面を傷つけるだけです。

他の偉大な魔術師のように、真の力は、新進気鋭の世代を刺激して、基礎に基づいて学んだことを新しく素晴らしいものに再考させることです。 皆様のご意見をお待ちしております！

## 作成者

このドキュメントの作成者：

![Jen ヘッドショット](assets/jen-headshot.png)

Jennifer Dungan（Torstar 社 Optimization Manager Analytics）

Adobe Analytics Champion
